#include "stm32f10x.h"

#define GPIOD_IDR (*(volatile unsigned *)0x40011408)

int check_bit(int bit_32num, int bit_index) { // 16진수를 입력받아  n번째(0부터 시작) bit가 0인지 1인지 판별하는 함수. (0일 경우 0, 1일 경우 1을 반환)
  bit_32num = bit_32num >> bit_index;
  
  if ((0x00000001 & bit_32num) == 0) {
    return 0;
  }
  else {
    return 1;
  }
}


void SysInit(void) {
    /* Set HSION bit */
    /* Internal Clock Enable */
    RCC->CR |= (uint32_t)0x00000001; //HSION

    /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
    RCC->CFGR &= (uint32_t)0xF0FF0000;

    /* Reset HSEON, CSSON and PLLON bits */
    RCC->CR &= (uint32_t)0xFEF6FFFF;

    /* Reset HSEBYP bit */
    RCC->CR &= (uint32_t)0xFFFBFFFF;

    /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
    RCC->CFGR &= (uint32_t)0xFF80FFFF;

    /* Reset PLL2ON and PLL3ON bits */
    RCC->CR &= (uint32_t)0xEBFFFFFF;

    /* Disable all interrupts and clear pending bits  */
    RCC->CIR = 0x00FF0000;

    /* Reset CFGR2 register */
    RCC->CFGR2 = 0x00000000;
}

void SetSysClock(void) {
    volatile uint32_t StartUpCounter = 0, HSEStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
    /* Enable HSE */
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    /* Wait till HSE is ready and if Time out is reached exit */
    do {
        HSEStatus = RCC->CR & RCC_CR_HSERDY;
        StartUpCounter++;
    } while ((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {
        HSEStatus = (uint32_t)0x01;
    }
    else {
        HSEStatus = (uint32_t)0x00;
    }

    if (HSEStatus == (uint32_t)0x01) {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;

//@TODO - 1 Set the clock, (//) 주석 표시를 없애고 틀린 값이 있다면 제대로 된 값으로 수정하시오  ★★★★★★★★★★★★★★★★★★★★
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
        /* PCLK2 = HCLK / ?, use PPRE2 */
        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV2; // PCLK2 = SYSCLK / 2
        /* PCLK1 = HCLK */
        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;

        /* Configure PLLs ------------------------------------------------------*/
        RCC->CFGR &= (uint32_t)~( RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLMULL4);

        RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL | RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
        RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL13 | RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
        // 25 / 5(PREDIV2_DIV5) * 13(PLL2MUL13) -> 아래 선택 -> / 5(PREDIV1_DIV5) * 4(PLLMULL4) = 52
//@End of TODO - 1 ★★★★★★★★★★★★★★★★★★★★

        /* Enable PLL2 */
        RCC->CR |= RCC_CR_PLL2ON;
        /* Wait till PLL2 is ready */
        while ((RCC->CR & RCC_CR_PLL2RDY) == 0)
        {
        }
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;
        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
        {
        }
        /* Select System Clock as output of MCO */
//@TODO - 2 Set the MCO port for system clock output ★★★★★★★★★★★★★★★★★★★★
        RCC->CFGR &= ~(uint32_t)RCC_CFGR_MCO;
        RCC->CFGR |= (uint32_t)RCC_CFGR_MCO_SYSCLK; // MCO가 SYSCLK 값을 출력한다 (SYSCLK 값은 위에서 계산된 52Mhz 로 지정되있다)
//@End of TODO - 2 ★★★★★★★★★★★★★★★★★★★★
    }
    else {
        /* If HSE fails to start-up, the application will have wrong clock
        configuration. User can add here some code to deal with this error */
    }
}

void RCC_Enable(void) {
//@TODO - 3 RCC Setting ★★★★★★★★★★★★★★★★★★★★
    /*---------------------------- RCC Configuration -----------------------------*/
    /* GPIO RCC Enable  */
    /* UART Tx, Rx, MCO port */
    RCC->APB2ENR |= (RCC_APB2ENR_IOPAEN | RCC_APB2ENR_AFIOEN | RCC_APB2ENR_IOPDEN); // GPIOA, D 활성화, Alternative function enable
    /* USART RCC Enable */
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN; // USART1  enable
}

void PortConfiguration(void) {
//@TODO - 4 GPIO Configuration ★★★★★★★★★★★★★★★★★★★★
    /* Reset(Clear) Port A CRH - MCO, USART1 TX,RX*/
    GPIOA->CRH &= ~(
	    (GPIO_CRH_CNF8 | GPIO_CRH_MODE8) |
	    (GPIO_CRH_CNF9 | GPIO_CRH_MODE9) |
	    (GPIO_CRH_CNF10 | GPIO_CRH_MODE10)
	);
    /* MCO Pin Configuration */
    GPIOA->CRH |= (GPIO_CRH_CNF8_1 | GPIO_CRH_MODE8); // MCO Pin의 CNF와 MODE를 1011 로 맞춘다. (OUTPUT, Alternative pull in - pull down)
    /* USART Pin Configuration */
    GPIOA->CRH |= (
                   (GPIO_CRH_CNF9_1 | GPIO_CRH_MODE9) | // USART Tx 와 Rx 의 CNF와 MODE 를 설정한다 (1011, 1000)
                   (GPIO_CRH_CNF10_1));
                     
    /* Reset(Clear) Port D CRH - User S1 Button */
    GPIOD->CRH &= ~(GPIO_CRH_CNF11 | GPIO_CRH_MODE11);
    /* User S1 Button Configuration */
    GPIOD->CRH |= GPIO_CRH_CNF11_1; // S1 스위치를 input mode로 설정한다
}

void UartInit(void) {
    /*---------------------------- USART CR1 Configuration -----------------------*/
    /* Clear M, PCE, PS, TE and RE bits */
    USART1->CR1 &= ~(uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE);
    /* Configure the USART Word Length, Parity and mode ----------------------- */
    /* Set the M bits according to USART_WordLength value */
//@TODO - 6: WordLength : 8bit ★★★★★★★★★★★★★★★★★★★★
    /* Set PCE and PS bits according to USART_Parity value */
    // PCE와 PS는 disable 이므로 설정 필요 X (초기값 0)
//@TODO - 7: Parity : None ★★★★★★★★★★★★★★★★★★★★
    /* Set TE and RE bits according to USART_Mode value */
    // 설정 필요 X
//@TODO - 8: Enable Tx and Rx ★★★★★★★★★★★★★★★★★★★★
    USART1->CR1 |= (USART_CR1_TE | USART_CR1_RE); // Tx와 Rx를 enable 한다. [reference USART_CR1 참조]

    /*---------------------------- USART CR2 Configuration -----------------------*/
    /* Clear STOP[13:12] bits */
    USART1->CR2 &= ~(uint32_t)(USART_CR2_STOP);
    /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
    USART1->CR2 &= ~(uint32_t)(USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN);
    /* Set STOP[13:12] bits according to USART_StopBits value */
//@TODO - 9: Stop bit : 1bit ★★★★★★★★★★★★★★★★★★★★
    // 이미 설정되있어서 설정 필요 X [reference USART_CR2 참조]
    

    /*---------------------------- USART CR3 Configuration -----------------------*/
    /* Clear CTSE and RTSE bits */
    USART1->CR3 &= ~(uint32_t)(USART_CR3_CTSE | USART_CR3_RTSE);
    /* Configure the USART HFC -------------------------------------------------*/
    /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
//@TODO - 10: CTS, RTS : disable ★★★★★★★★★★★★★★★★★★★★
    // PCE와 PS는 disable 이므로 설정 필요 X (초기값 0)

    /*---------------------------- USART BRR Configuration -----------------------*/
    /* Configure the USART Baud Rate -------------------------------------------*/
    /* Determine the integer part */
    /* Determine the fractional part */
//@TODO - 11: Calculate & configure BRR ★★★★★★★★★★★★★★★★★★★★
    USART1->BRR |= 0xA94; // 26000000/(16*9600) 해서 여러 과정을 거친 뒤 구한것.

    /*---------------------------- USART Enable ----------------------------------*/
    /* USART Enable Configuration */
//@TODO - 12: Enable UART (UE) ★★★★★★★★★★★★★★★★★★★★
    USART1->CR1 |= USART_CR1_UE; // UE를 활성화한다.
}

void delay(void){
    int i = 0;
    for(i=0;i<1000000;i++);
}

void SendData(uint16_t data) {
    /* Transmit Data */
	USART1->DR = data;

	/* Wait till TC is set */
	while ((USART1->SR & USART_SR_TC) == 0);
}

int main() {
	int i;
	char msg[] = "Hello Team08\r\n";
        
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
    
	
    SysInit();
    SetSysClock();
    RCC_Enable();
    PortConfiguration();
    UartInit();
    
    // if you need, init pin values here
    
    
    while (1) {
		//@TODO - 13: Send the message when button is pressed ★★★★★★★★★★★★★★★★★★★★
      
      if (check_bit(GPIOD_IDR, 11) == 0) { // GPIOD_IDR 이 1에서 0으로 바뀌었는지 확인 후 바뀌었다면 메세지 전송
        for(int i = 0; i < 14; i++) {
          SendData(msg[i]);
        }
      }
    }

}// end main